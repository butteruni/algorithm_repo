/*
有 n 个同学（编号为 1 到 n ）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 i 的同学的信息传递对象是编号为 Ti的同学。
游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。
当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？
*/
#include <bits/stdc++.h>
using namespace std;
int f[200002], d[200002], n, minn; // f保存祖先节点，d保存到其祖先节点的路径长。
int find(int x)
{
    if (f[x] != x) // 查找时沿途更新祖先节点和路径长。
    {
        int u = find(f[x]); // 记录父节点（会在递归中被更新）。
        d[x] += d[f[x]]; // 更新路径长（原来连在父节点上）。
        f[x] = u; // 更新祖先节点。
    }
    return f[x];
}
void check(int a, int b)
{
    int fa = find(a), fb = find(b); // 查找祖先节点。
    if (fa != fb)
    {
        f[fa] = fb;
        d[a] = d[b] + 1;
    } // 若不相连，则连接两点，更新父节点和路径长。
    else
        minn = min(minn, d[a] + d[b] + 1); // 若已连接，则更新最小环长度。
    return;
}
int main()
{
    int i, t;
    scanf("%d", &n);
    for (i = 1; i <= n; i++)
        f[i] = i; // 祖先节点初始化为自己，路径长为0。
    minn = 0x7777777;
    for (i = 1; i <= n; i++)
    {
        scanf("%d", &t);
        check(i, t); // 检查当前两点是否已有边相连接。
    }
    printf("%d", minn);
    return 0;
}
